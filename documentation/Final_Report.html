<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.555">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Zach Einolf">
<meta name="dcterms.date" content="2025-12-17">

<title>Did China Drive Its Own Image Problem? Analyzing Events and Filipino Public Opinion</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="Final_Report_files/libs/clipboard/clipboard.min.js"></script>
<script src="Final_Report_files/libs/quarto-html/quarto.js"></script>
<script src="Final_Report_files/libs/quarto-html/popper.min.js"></script>
<script src="Final_Report_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Final_Report_files/libs/quarto-html/anchor.min.js"></script>
<link href="Final_Report_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Final_Report_files/libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Final_Report_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Final_Report_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Final_Report_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="dark">


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul class="collapse">
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#methodology" id="toc-methodology" class="nav-link" data-scroll-target="#methodology">Methodology</a></li>
  <li><a href="#acled-analysis" id="toc-acled-analysis" class="nav-link" data-scroll-target="#acled-analysis">ACLED Analysis</a></li>
  <li><a href="#comparison-further-analysis" id="toc-comparison-further-analysis" class="nav-link" data-scroll-target="#comparison-further-analysis">Comparison &amp; Further Analysis</a></li>
  <li><a href="#comparison-further-analysis-1" id="toc-comparison-further-analysis-1" class="nav-link" data-scroll-target="#comparison-further-analysis-1">Comparison &amp; Further Analysis</a></li>
  <li><a href="#discussion" id="toc-discussion" class="nav-link" data-scroll-target="#discussion">Discussion</a></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Did China Drive Its Own Image Problem? Analyzing Events and Filipino Public Opinion</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Zach Einolf </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">December 17, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/FOREIGN201701261419000464992362047.jpg" class="img-fluid figure-img"></p>
<figcaption>Source: https://en.people.cn/n3/2017/0126/c90000-9172067.html</figcaption>
</figure>
</div>
<p>The GitHub repository for this project can be found at <a href="https://github.com/zeinolf/GVPT628_FinalProject" class="uri">https://github.com/zeinolf/GVPT628_FinalProject</a>.</p>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p><br></p>
</section>
<section id="methodology" class="level2">
<h2 class="anchored" data-anchor-id="methodology">Methodology</h2>
<section id="armed-conflict-location-event-data-acled-project" class="level4">
<h4 class="anchored" data-anchor-id="armed-conflict-location-event-data-acled-project"><em>Armed Conflict Location &amp; Event Data (ACLED) Project</em></h4>
<p><a href="https://acleddata.com/">ACLED</a> (Armed Conflict Location &amp; Event Data) is a United States-based non-profit organization dedicated to monitoring global conflict and crisis trends. They collect real-time data on violence and demonstrations by triaging wide ranges of publicly available information (PAI) (including local news, national news, etc.) for synthesis into distinct events. With each event, they document variables such as actors, fatality estimates, locations, event-types, dates, and more. For an example of the types of events that ACLED collects, see Figure 1. Event-types are classified using strict definition-based inclusion criteria. To this date, ACLED is one of the most robust conflict-data collection projects, and is widely recognized as a reputable and reliable data source.</p>
<p><strong>Figure 1.</strong> ACLED-compiled conflict events in The Philippines over past month (as of December 12, 2025)</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Screen%20Shot%202025-12-12%20at%202.19.03%20PM.png" class="img-fluid figure-img"></p>
<figcaption>Source: https://acleddata.com/platform/explorer</figcaption>
</figure>
</div>
<p>Conflict data from the ACLED repository can be viewed on their online dashboard tool for basic analysis as seen above. However, a look into conflict data from further back in time requires an API access token. This project specifically utilized the ACLED API in conjunction with the “acled.api” package in R to obtain conflict data for The Philippines and China. For more information regarding API access, see <a href="https://acleddata.com/api-documentation/getting-started" title="API Documentation">API Documentation</a>.</p>
<p>For The Philippines, ACLED collection begins as far back as January 1, 2016. Likewise, ACLED collection on China began on January 1, 2018. To answer the research question, all ACLED event data that occurred in The Philippines and China from their respective starting collection date until October 11, 2021 was pulled via the ACLED API. This specific end date was chosen in order to line up directly with the last day of administered surveying for the Asian Barometer Wave 6 questionnaire. Data from each respective API query was subsequently cleaned and reformatted for easier use. Variables kept included event_date, actor, location, event_type, disorder_type, and fatalities, among others. The Philippines data was specifically filtered for event notes or actors that contained mentions to “china”, “chinese”, “south china sea”, or “islands”. Likewise, the China data was specifically filtered for event notes or actors that contained mentions to “philippines”, “filipino”, “south china sea”, or “islands”. After reduction, the data was bound together and written into a SQLite database. This final database ultimately contained 47 distinct events that involved some level of conflict between Filipino and Chinese actors.</p>
<p>The code that what used to pull the data from the ACLED API for this project can be found <a href="https://github.com/zeinolf/GVPT628_FinalProject/blob/main/code/data_pull%2Bcleaning.Rmd">here</a>. The specific data that was stored using this API pull for use in this report can be found <a href="https://github.com/zeinolf/GVPT628_FinalProject/blob/main/data/acled_data.db">here.</a></p>
<p><br></p>
</section>
<section id="asian-barometer" class="level4">
<h4 class="anchored" data-anchor-id="asian-barometer"><em>Asian Barometer</em></h4>
<p><a href="https://asianbarometer.org/index">The Asian Barometer Survey</a> (ABS) is a public opinion survey project that captures the general attitudes of individuals living across Asia. Ultimately, the project aims to generate a region-wide base of scientifically reliable public opinion data on issues such as political values, democracy, the economy, etc. It was first established in 1971 by Fu Hu, Professor Emeritus of the Department of Political Science at National Taiwan University and Academician of Academia Sinica. It is now housed at the Fu Hu Center for East Asia Studies and works in collaboration with other notable “barometer” organizations around the world. Six waves of polling have occurred since 2001, with the organization currently administering its seventh wave as of late 2025.</p>
<p>Although the ABS project does not have a working API, they allow researchers and scholars to download their data at request. The data release form can be found <a href="https://asianbarometer.org/datar?page=d10">here</a>. This indiviudal project specifically utilized data from Waves 3, 4, 5, and 6 of the ABS Philippines survey. Waves 1 and 2 were excluded as questions regarding attitudes towards China were not introduced until Wave 3. Each wave contains a sample of 1,200 Filipino respondents that are collectively statistically representative of the entire population of the Philippines.</p>
<p>After each wave was read into R, a specific set of variables/questions were sub-selected for analysis. These included demographics such as gender, education, locality type, and age, as well as attitude-related variables (“psychographics”) that asked respondents questions related to their attitudes on China. Each wave required certain variables to be recoded and/or rescaled, as question numbers and scales often changed from wave to wave. Once reformatted, each sub-selected and cleaned wave dataset was written into a SQLite database for replicability purposes. All waves were then bound together and further cleaned to recode non-response answers (e.g., “I don’t know”, “Refused to answer”, etc.) as N/A values. With four different waves of 1,200 respondent datapoints, the final cleaned ABS data file contained 4800 rows of responses acoss 20 variables (that also include more administrative variables such as an identification number). This final ABS dataset was then written into a SQLite database for use in this report.</p>
<p>All raw ABS wave files and questionnaires can be found in the “W” folders <a href="https://github.com/zeinolf/GVPT628_FinalProject/tree/main/data">here</a>. The code that what used to load and clean the ABS data for this project can be found <a href="https://github.com/zeinolf/GVPT628_FinalProject/blob/main/code/data_pull%2Bcleaning.Rmd">here</a>. The resulting data files for the cleaned ABS data that were used for use in this report can be found <a href="https://github.com/zeinolf/GVPT628_FinalProject/tree/main/data">here</a>.</p>
<p><br></p>
</section>
</section>
<section id="acled-analysis" class="level2">
<h2 class="anchored" data-anchor-id="acled-analysis">ACLED Analysis</h2>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Final_Report_files/figure-html/unnamed-chunk-2-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p><br></p>
</section>
<section id="comparison-further-analysis" class="level2">
<h2 class="anchored" data-anchor-id="comparison-further-analysis">Comparison &amp; Further Analysis</h2>
<p><br></p>
</section>
<section id="comparison-further-analysis-1" class="level2">
<h2 class="anchored" data-anchor-id="comparison-further-analysis-1">Comparison &amp; Further Analysis</h2>
<p><br></p>
</section>
<section id="discussion" class="level2">
<h2 class="anchored" data-anchor-id="discussion">Discussion</h2>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Final_Report_files/figure-html/unnamed-chunk-3-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Final_Report_files/figure-html/unnamed-chunk-4-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Final_Report_files/figure-html/unnamed-chunk-5-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Final_Report_files/figure-html/unnamed-chunk-6-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<iframe src="https://zeinolf.shinyapps.io/gvpt628_finalproject/" width="145%" height="900px" style="border:none;">
</iframe>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>